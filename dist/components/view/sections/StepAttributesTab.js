"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var React = require("react");
var $ = require("jquery");
var WikiUtils_1 = require("./WikiUtils");
var StepAttributesTab = (function (_super) {
    __extends(StepAttributesTab, _super);
    function StepAttributesTab() {
        _super.apply(this, arguments);
    }
    StepAttributesTab.prototype.componentDidMount = function () {
        $('html, body').animate({ scrollTop: $("#stepsApi").offset().top }, 'slow');
    };
    StepAttributesTab.prototype.render = function () {
        return React.createElement("div", {className: "tab-pane active", id: "stepsApi"}, this._stepAttributesBlock());
    };
    StepAttributesTab.prototype._stepAttributesBlock = function () {
        return React.createElement("ul", {className: "attributes-block-api"}, WikiUtils_1.tabNotice("Step attributes define the behavior of the current step only. Each step inherits all of the attributes of the tour, however, by re-declare the same attributes, you will override the pre-defined attributes in the tour."), React.createElement("hr", null), WikiUtils_1.createAttributeLine("content: string (required)", "The introduction, or direction you want to show the users in this current step."), WikiUtils_1.attributesWithCode("position: string (required)", ["Default: '", "', this is the position of the bubble relative to the target. The other options are: '", "', '", "', '", "' and '", "'. When you set it to float, the bubble will not be attached to any target, instead it will just FLOAT in the middle of the screen."], ["bottom", "top", "left", "right", "float"]), WikiUtils_1.attributesWithCode("target: string (required unless float)", ["Unless the position is set to", " you must set a target for each step. The target is the only thing that is visible to users, the rest of the application will be greyed out. The bubble will be attached to the target in the given position."], ["float"]), React.createElement("hr", null), WikiUtils_1.attributesWithCode("type: string", ["Default '", "'.", " step will have 'i' icon indicating that users just need to read the info and click on directional button. ", "step will have 'action' icon indicating that users have to interact with the target before proceeding to next step."], ["info", "info", "action"]), WikiUtils_1.createAttributeLine("title: string", "The title will appear on top of the content block."), WikiUtils_1.attributesWithCode("nextStepTrigger: string", ["This is another way for you to trigger the next step in your tour. FlexTourJS will attach an onclick listener to the element corresponds to the DOM selector string. If you set ", ", the framework will use the step ", " as the trigger."], ["nextStepTrigger:'@target@'", "target"]), WikiUtils_1.attributesWithCode("flashTarget: string", ["Similar to ", " the value of this attribute is a DOM selector string. When set, the framework will put an flashing border around the element to indicate that user should do something with that element. You can also set ", " to put the flashing border around step target."], ["nextStepTrigger", "flashTarget:'@target@'"]), React.createElement("hr", null), WikiUtils_1.tabNotice("You should use the below attributes with care. These attributes can be very powerful if used correctly."), WikiUtils_1.attributesWithCode("modal: boolean", ["Default: ", ", when set to ", " FlexTourJS will attach a listener to the window scroll event. It will debounce every 200 milliseconds on scroll event and re-render everything FlexTourJS contains. This is extremely useful when you have a floating element: modal, popup dialog, etc. because they move as you scroll. If the target is a stationary element, you should NOT use this attribute because it is a waste of rendering effort."], ["false", "true"]), WikiUtils_1.attributesWithCode("scrollLock: boolean", ["Default: ", ", when set to ", " the framework will disable page scrolling to keep the element in place. The lock will be released when you move onto the next step or end the tour so it will not alter your application behavior. This attribute also targets the moving element as ", " attribute, however, by locking scrolling, FlexTourJS does NOT need to re-render thus improve performance."], ["false", "true", "modal"]), WikiUtils_1.attributesWithCode("transition: boolean", ["Default: ", ", when set to ", " the framework will immediately proceed to the next step. Why is it useful? When your next step takes a long period of time (several seconds to minutes), you can use this step as a notification to ask users to wait, otherwise they would thing the system is hung. This feature is usually used to compensate for the slow processing speed in production environment. You should only use this feature if the next step has the ", " condition."], ["false", "true", "waitFor"]), WikiUtils_1.attributesWithCode("skip: number", ["If you want to let users skip to a specific step, set the index number of the destination step here. However, you have to make sure that the destination step's target exists and is visible in the DOM. Furthermore, this attribute can be used as backup route for", " attribute."], ["prerequisites: proceedIf"]), WikiUtils_1.attributesWithCode("dragAndDrop: boolean", ["Default: ", ", when set to ", " the framework will attach dragstart and dragend event onto the step's target. When the target is dragged, the tour engine will be paused. When the target is dropped, the tour will be resumed to the next step. Developers must check to see if users drop the target at correct location, if it is not, they can revert the flow to the previous step."], ["false", "true"]), WikiUtils_1.attributesWithCode("multipage: boolean", ["Default: ", ", when set to ", " FlexTourJS will automatically store the current tour id and current step index into localstorage. The framework assumes that the next step will be in another page. This is most useful to be used with ", " attribute. Developers have to ensure that the next page has FlexTourJS and the tour objects loaded so that it can continue the tour automatically."], ["false", "true", "nextStepTrigger"]), WikiUtils_1.attributesWithCode("savePoint: boolean", ["Default: ", ", when you resume the tour, occassionaly the target of your step is not visible or doesn not exist: target is in a modal that users have to click on a button to get to. FlexTourJS will at first check to see if your paused step's target is available, when it is not, it will loop back to find the closest step that has ", ". As in the example, the button that open the modal should be your savePoint as it sets up the application for the following steps."], ["false", "savePoint:true"]), React.createElement("hr", null), WikiUtils_1.createAttributeLine("prerequisites: string[]", "This is the most complicated as well as the most powerful attribute in FlexTourJS. There are 3 types of conditions that you can use to make sure the next/previous/branch step is safe for the tour engine to proceed. All of these conditions will be executed before FlexTourJS create/modify the overlays, content bubble, buttons, etc. Furthermore, you can also dynamically modify the step description on the fly which is extremely useful for dynamically created element that does not exist until the current step."), React.createElement("ol", null, WikiUtils_1.attributesWithCode("prerequisites: ['function1', 'function2']", ["Type 1: error checking. Each element in the array is the name of a function in ", ". See FunctionsList construction section below for more information. Each function will be executed in order, and at any point that the function returns ", " the next step will NOT be allowed. The framework will still show the current step until all prerequisites of the next step return ", ". Bonus: FlexTourJS will pass the step object to your function so that you can modify it on the fly: ", "."], ["functionsList", "false/undefined", "true", "functionsList.function1 = function(currentStep) {// Do what you want with the step object here};"]), WikiUtils_1.attributesWithCode("prerequisites: ['?waitForFuncName:param1,param2,...']", ["Type 2: wait for condition. Similarly, the ", " is the name of a function in ", ". The parameters (DOM element selector) will be passed to you in the form of array string. This function uses ", " and ", " to continuously check until either function returns ", " or it runs out of attempts. This function has to return ", " for the framework to continue to next step. If the step runs out of retries, it will check the backup route as describe in option 3, so you should set a backup route if your step target might or might not be available."], ["waitForFuncName", "functionsList", "retries", "waitIntervals", "true", "true"]), WikiUtils_1.attributesWithCode("prerequisites: ['!proceedIfFuncName:param1,param2,...']", ["Type 3: proceed if condition. The ", " corresponds to a function in ", ". The parameters (DOM element selector) will be passed to you in the form of array string. This condition is your backup route. This is where you decide whether you should end the tour now since the next step will never be available. Logic: proceedIfFuncName should return ", " if you are absolutely sure that the next step is available and safe. On the other hand, the function must return ", " for the framework to skip ahead 1 step if your tour is moving forward, and skip back 1 step if your tour is moving backward. Furthermore, if you use this condition with ", " attribute set in the step object, FlexTourJS will skip ahead to that pre-set step. Notice: as this is the backup route, you should set it at the end of ", " array."], ["proceedIfFuncName", "functionsList", "true", "false", "skip", "prerequisites"]), WikiUtils_1.attributesWithCode("isVisible, doesExist", ["These are the 2 built-in functions that you can use for your prerequisites. I.e: ", " which will continuously check until both step's target and $el1 are visible. Similarly, ", " will check continuously until both step's target and $el1 exist in the DOM. To use these 2 functions in option 3: ", " check for the visibility of those elements for the last time, if they are still not visible, the framework will skip the next step. Similarly for ", " which check for the last time if elements exist in the DOM."], ["'?isVisible:@target@,$el1'", "?doesExist:@target@,$el1", "'!isVisible:@target@,$el1'", "!doesExist:@target@,$el1"])));
    };
    return StepAttributesTab;
}(React.Component));
exports.StepAttributesTab = StepAttributesTab;
//# sourceMappingURL=StepAttributesTab.js.map